worker_processes  1;
error_log logs/error2.log;
events {
    worker_connections 1024;
}
http {
    upstream request_page {
        server localhost:8087;
    }


    upstream backend {
        server 0.0.0.1;   # just an invalid address as a place holder

        balancer_by_lua_block {
            local balancer = require "ngx.balancer"
            local md5 = require 'md5'
            local hosts = {"192.168.182.22", "192.168.117.87"}
	    -- TODO use lua-resty-dns to get IPs
            -- local hosts = {"tkb-sts-0.dullahan.default.svc.cluster.local", "tkb-sts-1.dullahan.default.svc.cluster.local"}

            -- compute the hash of the url argument, mod the hash by the number of backend servers 
            -- pick a backend server (for now, just vary the port on 127.0.0.2) based on the mod hash
            -- in a real-world example, the backend servers would likely be nginx pods in a stateful set
            local pageUrl = tostring(ngx.var.arg_url)
	    local md5Hash = md5.sumhexa(pageUrl)
	    local hash = string.sub(md5Hash, 1, 8)
	    local hashNum = tonumber("0x" .. hash)
	    local serverNum = hashNum % #hosts
            local host = hosts[serverNum + 1]
	    local port = 80
            ngx.log(ngx.ERR, "host is: ", host)

            local ok, err = balancer.set_current_peer(host, port)
            if not ok then
                ngx.log(ngx.ERR, "failed to set the current peer: ", err)
                return ngx.exit(500)
            end
        }

        keepalive 10;  # connection pool
    }

    upstream form_uploader_backend {
        server 0.0.0.1;   # just an invalid address as a place holder

        balancer_by_lua_block {
            local balancer = require "ngx.balancer"
            local host = "127.0.0.2"
	    local serverPorts = {8083, 8084}

            local args, err = ngx.req.get_post_args()
            if not args then
                ngx.log(ngx.ERR, "failed to get post args: ", err)
                return
            end

            for key, val in pairs(args) do
                if key == "pageUrl" then
                    pageUrl = val
                end
                if key == "pageContent" then
                    pageContent = val
                end
                if key == "hash" then
                    hash = val
                end
            end
            ngx.log(ngx.ERR, "**** backend pageUrl=" .. pageUrl .. ", pageContent=".. pageContent)

            if not pageUrl then
                ngx.log(ngx.ERR, "couldn't find pageUrl in post args: ")
                return ngx.exit(500)
            end
            if not hash then
                ngx.log(ngx.ERR, "couldn't find hash in post args: ")
                return ngx.exit(500)
            end

	    local hashNum = tonumber("0x" .. hash)
	    local serverNum = hashNum % #serverPorts
	    local port = serverPorts[serverNum + 1]
            ngx.log(ngx.ERR, "---- hash is ", hash, ", port is ", port)

            local ok, err = balancer.set_current_peer(host, port)
            if not ok then
                ngx.log(ngx.ERR, "failed to set the current peer: ", err)
                return ngx.exit(500)
            end
        }

        keepalive 10;  # connection pool
    }

    server {
        # this is the main entry point
	# hit the server with a url such has http://54.151.101.216:8080/?url=abc
	# Examples of url -> file mappings:
	# http://localhost:8080/?url=a
        #   http://tkb-sts-1.dullahan.default.svc.cluster.local/cache/0cc175b9
	# http://localhost:8080/?url=ab
        #   http://tkb-sts-1.dullahan.default.svc.cluster.local/cache/187ef443
	# http://localhost:8080/?url=abc
        #   http://tkb-sts-0.dullahan.default.svc.cluster.local/cache/90015098
        listen 127.0.0.1:8081;

        error_page 404 = @404;

        location / {
            # make use of the upstream named "backend" defined above:
	    proxy_intercept_errors on;
            rewrite_by_lua_block {
                -- Compute the hash of the url argument, and pass to the upstream backend
		local md5 = require 'md5'
                local pageUrl = tostring(ngx.var.arg_url)
		local md5Hash = md5.sumhexa(pageUrl)
		hash = string.sub(md5Hash, 1,8)
                ngx.log(ngx.ERR, "pageUrl", pageUrl, " hash: ", hash)
		-- rewrite uri so we use hash instead of url arg
                ngx.req.set_uri("/cache/" .. hash, false)
            }
            # proxy to backend, using hash-based routing
            proxy_pass http://backend;
        }

        location @404 {
	    proxy_pass http://request_page;
	}

    }

    ## For testing only.  remove this once this is offloaded to the shard workers

    server {
        listen 127.0.0.2:8082;

        location /write_page {
            lua_need_request_body on;
            content_by_lua_block {
                ngx.say("8082 we're writing your page to disk...")
                local content_base_path = '/usr/local/openresty/nginx/cache/'

                local args, err = ngx.req.get_post_args()
                if not args then
                    ngx.log(ngx.ERR, "failed to get post args: ", err)
                    return
                end

                for key, val in pairs(args) do
                    if key == "pageUrl" then
                        pageUrl = val
                    end
                    if key == "pageContent" then
                        pageContent = val
                    end
                    if key == "hash" then
                        hash = val
                    end
                end
                ngx.say("pageUrl=" .. pageUrl .. "\nhash=".. hash .. "\npageContent=\n".. pageContent)

                filename = content_base_path .. hash
                ngx.say("filename=" .. filename)
                file = io.open(filename, "w+")
                if not file then
                    ngx.say("failed to open file ", file_name)
                    return
                end
                file:write(pageContent)
                file:close()
            }
        }
    }


    server {
        listen 127.0.0.2:8083;

        location /write_page {
            lua_need_request_body on;
            content_by_lua_block {
                ngx.say("8083 we're writing your page to disk...")
                local content_base_path = '/usr/local/openresty/nginx/cache/'

                local args, err = ngx.req.get_post_args()
                if not args then
                    ngx.log(ngx.ERR, "failed to get post args: ", err)
                    return
                end

                for key, val in pairs(args) do
                    if key == "pageUrl" then
                        pageUrl = val
                    end
                    if key == "pageContent" then
                        pageContent = val
                    end
                    if key == "hash" then
                        hash = val
                    end
                end
                ngx.say("pageUrl=" .. pageUrl .. "\nhash=".. hash .. "\npageContent=\n".. pageContent)

                filename = content_base_path .. hash
                ngx.say("filename=" .. filename)
                file = io.open(filename, "w+")
                if not file then
                    ngx.say("failed to open file ", file_name)
                    return
                end
                file:write(pageContent)
                file:close()
            }
        }
    }

    server {
        # this is the mock backend for posting page requests
        listen 8087;
        
        location / {
            rewrite_by_lua_block {
                local pageUrl = ngx.var.arg_url
		local pageContent = "This is a generated page for testing.\n"
		pageContent = pageContent .. "pageUrl=" .. pageUrl .. "\n"
		pageContent = pageContent .. "hash=" .. hash .. "\n"
                -- convert get into a post and proxy to page_response handler
                ngx.req.read_body()
		ngx.req.set_method(ngx.HTTP_POST)
		ngx.req.set_uri("/write_page", false)
                ngx.req.set_body_data("pageUrl=" .. pageUrl .. "&pageContent=" .. pageContent)
	    }
	    proxy_pass http://form_uploader_backend;
        }
    }
}